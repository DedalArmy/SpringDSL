/*
 * generated by Xtext 2.12.0
 */
package org.xtext.spring.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.spring.services.SpringConfigDslGrammarAccess;
import org.xtext.spring.springConfigDsl.AfterAdvise;
import org.xtext.spring.springConfigDsl.AfterReturning;
import org.xtext.spring.springConfigDsl.AfterThowing;
import org.xtext.spring.springConfigDsl.Alias;
import org.xtext.spring.springConfigDsl.AnnotationConfig;
import org.xtext.spring.springConfigDsl.AopAdvisor;
import org.xtext.spring.springConfigDsl.AopAspect;
import org.xtext.spring.springConfigDsl.AopAspectJAutoproxy;
import org.xtext.spring.springConfigDsl.AopConfig;
import org.xtext.spring.springConfigDsl.AopDefaultImplInterface;
import org.xtext.spring.springConfigDsl.AopDelegateImplRef;
import org.xtext.spring.springConfigDsl.AopInclude;
import org.xtext.spring.springConfigDsl.AopPointcut;
import org.xtext.spring.springConfigDsl.AopScopedProxy;
import org.xtext.spring.springConfigDsl.AroundAdvise;
import org.xtext.spring.springConfigDsl.Attribute;
import org.xtext.spring.springConfigDsl.BeforeAdvise;
import org.xtext.spring.springConfigDsl.Component;
import org.xtext.spring.springConfigDsl.ComponentScan;
import org.xtext.spring.springConfigDsl.Configuration;
import org.xtext.spring.springConfigDsl.CreationMethod;
import org.xtext.spring.springConfigDsl.DataString;
import org.xtext.spring.springConfigDsl.DeclareParents;
import org.xtext.spring.springConfigDsl.ExcludeFilter;
import org.xtext.spring.springConfigDsl.Factory;
import org.xtext.spring.springConfigDsl.Feature;
import org.xtext.spring.springConfigDsl.Import;
import org.xtext.spring.springConfigDsl.IncludeFilter;
import org.xtext.spring.springConfigDsl.Interface;
import org.xtext.spring.springConfigDsl.Key;
import org.xtext.spring.springConfigDsl.LoadTimeWeaver;
import org.xtext.spring.springConfigDsl.LookupMethod;
import org.xtext.spring.springConfigDsl.MVC;
import org.xtext.spring.springConfigDsl.Map;
import org.xtext.spring.springConfigDsl.MapEntry;
import org.xtext.spring.springConfigDsl.MbeanExport;
import org.xtext.spring.springConfigDsl.MbeanServer;
import org.xtext.spring.springConfigDsl.Meta;
import org.xtext.spring.springConfigDsl.Prop;
import org.xtext.spring.springConfigDsl.PropertyFile;
import org.xtext.spring.springConfigDsl.PropertyOverride;
import org.xtext.spring.springConfigDsl.PropertyPlaceholder;
import org.xtext.spring.springConfigDsl.Props;
import org.xtext.spring.springConfigDsl.Qualifier;
import org.xtext.spring.springConfigDsl.QualifierAttribute;
import org.xtext.spring.springConfigDsl.Reference;
import org.xtext.spring.springConfigDsl.SpringConfigDslPackage;
import org.xtext.spring.springConfigDsl.SpringConfigured;
import org.xtext.spring.springConfigDsl.SpringProject;
import org.xtext.spring.springConfigDsl.TxAdvise;
import org.xtext.spring.springConfigDsl.TxAnnotation;
import org.xtext.spring.springConfigDsl.TxAttribute;
import org.xtext.spring.springConfigDsl.TxJtaTransactionManager;
import org.xtext.spring.springConfigDsl.TxMethod;
import org.xtext.spring.springConfigDsl.UtilConstant;
import org.xtext.spring.springConfigDsl.UtilList;
import org.xtext.spring.springConfigDsl.UtilMap;
import org.xtext.spring.springConfigDsl.UtilProperties;
import org.xtext.spring.springConfigDsl.UtilPropertyPath;
import org.xtext.spring.springConfigDsl.UtilSet;
import org.xtext.spring.springConfigDsl.sList;
import org.xtext.spring.springConfigDsl.sSet;

@SuppressWarnings("all")
public class SpringConfigDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpringConfigDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpringConfigDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpringConfigDslPackage.AFTER_ADVISE:
				sequence_AfterAdvise(context, (AfterAdvise) semanticObject); 
				return; 
			case SpringConfigDslPackage.AFTER_RETURNING:
				sequence_AfterReturning(context, (AfterReturning) semanticObject); 
				return; 
			case SpringConfigDslPackage.AFTER_THOWING:
				sequence_AfterThowing(context, (AfterThowing) semanticObject); 
				return; 
			case SpringConfigDslPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case SpringConfigDslPackage.ANNOTATION_CONFIG:
				sequence_AnnotationConfig(context, (AnnotationConfig) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_ADVISOR:
				sequence_AopAdvisor(context, (AopAdvisor) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_ASPECT:
				sequence_AopAspect(context, (AopAspect) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_ASPECT_JAUTOPROXY:
				sequence_AopAspectJAutoproxy(context, (AopAspectJAutoproxy) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_CONFIG:
				sequence_AopConfig(context, (AopConfig) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_DEFAULT_IMPL_INTERFACE:
				sequence_AopDefaultImplInterface(context, (AopDefaultImplInterface) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_DELEGATE_IMPL_REF:
				sequence_AopDelegateImplRef(context, (AopDelegateImplRef) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_INCLUDE:
				sequence_AopInclude(context, (AopInclude) semanticObject); 
				return; 
			case SpringConfigDslPackage.AOP_POINTCUT:
				if (rule == grammarAccess.getAopPointcutRule()) {
					sequence_AopPointcut(context, (AopPointcut) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPointCutExpressionRule()) {
					sequence_PointCutExpression(context, (AopPointcut) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.AOP_SCOPED_PROXY:
				sequence_AopScopedProxy(context, (AopScopedProxy) semanticObject); 
				return; 
			case SpringConfigDslPackage.AROUND_ADVISE:
				sequence_AroundAdvise(context, (AroundAdvise) semanticObject); 
				return; 
			case SpringConfigDslPackage.ATTRIBUTE:
				if (rule == grammarAccess.getAttributSimpleValueRule()) {
					sequence_AttributSimpleValue(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributSimpleRule()) {
					sequence_AttributSimple(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeAttRule()) {
					sequence_AttributeAtt(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeTagRule()) {
					sequence_AttributeTag(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractKeyValueRule()
						|| rule == grammarAccess.getAbstractArtefactRule()) {
					sequence_AttributeTag_IdRefTag(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributesConsRule()) {
					sequence_AttributesCons(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIdRefTagRule()) {
					sequence_IdRefTag(context, (Attribute) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.BEFORE_ADVISE:
				sequence_BeforeAdvise(context, (BeforeAdvise) semanticObject); 
				return; 
			case SpringConfigDslPackage.CLASS:
				sequence_Class(context, (org.xtext.spring.springConfigDsl.Class) semanticObject); 
				return; 
			case SpringConfigDslPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case SpringConfigDslPackage.COMPONENT_SCAN:
				sequence_ComponentScan(context, (ComponentScan) semanticObject); 
				return; 
			case SpringConfigDslPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case SpringConfigDslPackage.CREATION_METHOD:
				sequence_CreationMethod(context, (CreationMethod) semanticObject); 
				return; 
			case SpringConfigDslPackage.DATA_STRING:
				sequence_DataString(context, (DataString) semanticObject); 
				return; 
			case SpringConfigDslPackage.DECLARE_PARENTS:
				sequence_DeclareParents(context, (DeclareParents) semanticObject); 
				return; 
			case SpringConfigDslPackage.EXCLUDE_FILTER:
				sequence_ExcludeFilter(context, (ExcludeFilter) semanticObject); 
				return; 
			case SpringConfigDslPackage.FACTORY:
				sequence_Factory(context, (Factory) semanticObject); 
				return; 
			case SpringConfigDslPackage.FEATURE:
				if (rule == grammarAccess.getCNamespaceRule()) {
					sequence_CNamespace(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstructorArgAttRule()) {
					sequence_ConstructorArgAtt(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstructorArgRule()) {
					sequence_ConstructorArg_ConstructorArgAtt(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureRule()) {
					sequence_ConstructorArg_ConstructorArgAtt_Property(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPNamespaceRule()) {
					sequence_PNamespace(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyRule()) {
					sequence_Property(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SpringConfigDslPackage.INCLUDE_FILTER:
				sequence_IncludeFilter(context, (IncludeFilter) semanticObject); 
				return; 
			case SpringConfigDslPackage.INTERFACE:
				sequence_AopImplInterface(context, (Interface) semanticObject); 
				return; 
			case SpringConfigDslPackage.KEY:
				if (rule == grammarAccess.getKeyRule()) {
					sequence_Key(context, (Key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryKeyAttRule()) {
					sequence_MapEntryKeyAtt(context, (Key) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.LOAD_TIME_WEAVER:
				sequence_LoadTimeWeaver(context, (LoadTimeWeaver) semanticObject); 
				return; 
			case SpringConfigDslPackage.LOOKUP_METHOD:
				sequence_LookupMethod(context, (LookupMethod) semanticObject); 
				return; 
			case SpringConfigDslPackage.MVC:
				sequence_MVC(context, (MVC) semanticObject); 
				return; 
			case SpringConfigDslPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case SpringConfigDslPackage.MAP_ENTRY:
				if (rule == grammarAccess.getMapEntryAttRule()) {
					sequence_MapEntryAtt(context, (MapEntry) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryKeyRule()) {
					sequence_MapEntryKey(context, (MapEntry) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryValueRule()) {
					sequence_MapEntryValue(context, (MapEntry) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryRule()) {
					sequence_MapEntry_MapEntryAtt_MapEntryKey_MapEntryValue(context, (MapEntry) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.MBEAN_EXPORT:
				sequence_MbeanExport(context, (MbeanExport) semanticObject); 
				return; 
			case SpringConfigDslPackage.MBEAN_SERVER:
				sequence_MbeanServer(context, (MbeanServer) semanticObject); 
				return; 
			case SpringConfigDslPackage.META:
				sequence_MetaTag(context, (Meta) semanticObject); 
				return; 
			case SpringConfigDslPackage.PROP:
				sequence_Prop(context, (Prop) semanticObject); 
				return; 
			case SpringConfigDslPackage.PROPERTY_FILE:
				if (rule == grammarAccess.getMVCRule()) {
					sequence_MVC_PropertyFileSimple(context, (PropertyFile) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyFileSimpleRule()) {
					sequence_PropertyFileSimple(context, (PropertyFile) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyFileRule()) {
					sequence_PropertyFile(context, (PropertyFile) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.PROPERTY_OVERRIDE:
				sequence_PropertyOverride(context, (PropertyOverride) semanticObject); 
				return; 
			case SpringConfigDslPackage.PROPERTY_PLACEHOLDER:
				sequence_PropertyPlaceholder(context, (PropertyPlaceholder) semanticObject); 
				return; 
			case SpringConfigDslPackage.PROPS:
				sequence_Props(context, (Props) semanticObject); 
				return; 
			case SpringConfigDslPackage.QUALIFIER:
				sequence_Qualifier(context, (Qualifier) semanticObject); 
				return; 
			case SpringConfigDslPackage.QUALIFIER_ATTRIBUTE:
				sequence_QualifierAttribute(context, (QualifierAttribute) semanticObject); 
				return; 
			case SpringConfigDslPackage.REFERENCE:
				if (rule == grammarAccess.getAttributesConsRule()) {
					sequence_AttributesCons(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryValRefRule()) {
					sequence_MapEntryValRef(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntrykeyRefRule()) {
					sequence_MapEntrykeyRef(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReferenceAttRule()) {
					sequence_ReferenceAtt(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReferenceComponentRule()) {
					sequence_ReferenceComponent(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractKeyValueRule()
						|| rule == grammarAccess.getAbstractArtefactRule()
						|| rule == grammarAccess.getReferenceTagRule()) {
					sequence_ReferenceTag(context, (Reference) semanticObject); 
					return; 
				}
				else break;
			case SpringConfigDslPackage.SPRING_CONFIGURED:
				sequence_SpringConfigured(context, (SpringConfigured) semanticObject); 
				return; 
			case SpringConfigDslPackage.SPRING_PROJECT:
				sequence_SpringProject(context, (SpringProject) semanticObject); 
				return; 
			case SpringConfigDslPackage.TX_ADVISE:
				sequence_TxAdvise(context, (TxAdvise) semanticObject); 
				return; 
			case SpringConfigDslPackage.TX_ANNOTATION:
				sequence_TxAnnotation(context, (TxAnnotation) semanticObject); 
				return; 
			case SpringConfigDslPackage.TX_ATTRIBUTE:
				sequence_TxAttribute(context, (TxAttribute) semanticObject); 
				return; 
			case SpringConfigDslPackage.TX_JTA_TRANSACTION_MANAGER:
				sequence_TxJtaTransactionManager(context, (TxJtaTransactionManager) semanticObject); 
				return; 
			case SpringConfigDslPackage.TX_METHOD:
				sequence_TxMethod(context, (TxMethod) semanticObject); 
				return; 
			case SpringConfigDslPackage.UTIL_CONSTANT:
				sequence_UtilConstant(context, (UtilConstant) semanticObject); 
				return; 
			case SpringConfigDslPackage.UTIL_LIST:
				sequence_UtilList(context, (UtilList) semanticObject); 
				return; 
			case SpringConfigDslPackage.UTIL_MAP:
				sequence_UtilMap(context, (UtilMap) semanticObject); 
				return; 
			case SpringConfigDslPackage.UTIL_PROPERTIES:
				sequence_UtilProperties(context, (UtilProperties) semanticObject); 
				return; 
			case SpringConfigDslPackage.UTIL_PROPERTY_PATH:
				sequence_UtilPropertyPath(context, (UtilPropertyPath) semanticObject); 
				return; 
			case SpringConfigDslPackage.UTIL_SET:
				sequence_UtilSet(context, (UtilSet) semanticObject); 
				return; 
			case SpringConfigDslPackage.SLIST:
				sequence_sList(context, (sList) semanticObject); 
				return; 
			case SpringConfigDslPackage.SSET:
				sequence_sSet(context, (sSet) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Advise returns AfterAdvise
	 *     AfterAdvise returns AfterAdvise
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString)+
	 */
	protected void sequence_AfterAdvise(ISerializationContext context, AfterAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns AfterReturning
	 *     AfterReturning returns AfterReturning
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString | returningValue=ValidString)+
	 */
	protected void sequence_AfterReturning(ISerializationContext context, AfterReturning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns AfterThowing
	 *     AfterThowing returns AfterThowing
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString | throwingValue=ValidString)+
	 */
	protected void sequence_AfterThowing(ISerializationContext context, AfterThowing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     (origin=[Component|ValidString] alias=ValidString)
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.ALIAS__ORIGIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.ALIAS__ORIGIN));
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.ALIAS__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.ALIAS__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasAccess().getOriginComponentValidStringParserRuleCall_3_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.ALIAS__ORIGIN, false));
		feeder.accept(grammarAccess.getAliasAccess().getAliasValidStringParserRuleCall_5_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns AnnotationConfig
	 *     ContextType returns AnnotationConfig
	 *     AnnotationConfig returns AnnotationConfig
	 *
	 * Constraint:
	 *     {AnnotationConfig}
	 */
	protected void sequence_AnnotationConfig(ISerializationContext context, AnnotationConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopAdvisor returns AopAdvisor
	 *
	 * Constraint:
	 *     (adviceRef=[TxAdvise|ValidString] | name=ValidString | order=ValidString | pointcut=PointCutExpression | pointcutRef=[AopPointcut|ValidString])+
	 */
	protected void sequence_AopAdvisor(ISerializationContext context, AopAdvisor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aspect returns AopAspectJAutoproxy
	 *     AspectType returns AopAspectJAutoproxy
	 *     AopAspectJAutoproxy returns AopAspectJAutoproxy
	 *
	 * Constraint:
	 *     ((exposeProxy=sBoolean | proxyTrajetClass=sBoolean)* aopincludes+=AopInclude*)
	 */
	protected void sequence_AopAspectJAutoproxy(ISerializationContext context, AopAspectJAutoproxy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopAspect returns AopAspect
	 *
	 * Constraint:
	 *     (
	 *         (name=ValidString | order=ValidString | backingBeanRef=[Component|ValidString])+ 
	 *         aopPointcuts+=AopPointcut? 
	 *         ((declaredParents+=DeclareParents | advises+=Advise)? aopPointcuts+=AopPointcut?)*
	 *     )
	 */
	protected void sequence_AopAspect(ISerializationContext context, AopAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aspect returns AopConfig
	 *     AspectType returns AopConfig
	 *     AopConfig returns AopConfig
	 *
	 * Constraint:
	 *     ((exposeProxy=sBoolean | proxyTrajetClass=sBoolean)* aopPointcuts+=AopPointcut* aopAdvisors+=AopAdvisor* aspects+=AopAspect*)
	 */
	protected void sequence_AopConfig(ISerializationContext context, AopConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopDefaultImplInterface returns AopDefaultImplInterface
	 *
	 * Constraint:
	 *     name=ValidString
	 */
	protected void sequence_AopDefaultImplInterface(ISerializationContext context, AopDefaultImplInterface semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.AOP_DEFAULT_IMPL_INTERFACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.AOP_DEFAULT_IMPL_INTERFACE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopDefaultImplInterfaceAccess().getNameValidStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopDelegateImplRef returns AopDelegateImplRef
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_AopDelegateImplRef(ISerializationContext context, AopDelegateImplRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.AOP_DELEGATE_IMPL_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.AOP_DELEGATE_IMPL_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopDelegateImplRefAccess().getRefComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.AOP_DELEGATE_IMPL_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopImplInterface returns Interface
	 *
	 * Constraint:
	 *     name=ValidString
	 */
	protected void sequence_AopImplInterface(ISerializationContext context, Interface semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.INTERFACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.INTERFACE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopImplInterfaceAccess().getNameValidStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopInclude returns AopInclude
	 *
	 * Constraint:
	 *     aopInclude=[Component|ValidString]
	 */
	protected void sequence_AopInclude(ISerializationContext context, AopInclude semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.AOP_INCLUDE__AOP_INCLUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.AOP_INCLUDE__AOP_INCLUDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopIncludeAccess().getAopIncludeComponentValidStringParserRuleCall_2_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.AOP_INCLUDE__AOP_INCLUDE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopPointcut returns AopPointcut
	 *
	 * Constraint:
	 *     (expression=ValidString | name=ValidString)+
	 */
	protected void sequence_AopPointcut(ISerializationContext context, AopPointcut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopScopedProxy returns AopScopedProxy
	 *
	 * Constraint:
	 *     proxyTargetClass=ValidString?
	 */
	protected void sequence_AopScopedProxy(ISerializationContext context, AopScopedProxy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns AroundAdvise
	 *     AroundAdvise returns AroundAdvise
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString)+
	 */
	protected void sequence_AroundAdvise(ISerializationContext context, AroundAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributSimpleValue returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_AttributSimpleValue(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributSimpleValueAccess().getValueValidStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributSimple returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_AttributSimple(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributSimpleAccess().getValueValidStringParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeAtt returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_AttributeAtt(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAttAccess().getValueValidStringParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeTag returns Attribute
	 *
	 * Constraint:
	 *     (type=ValidString? value=QSTRING?)
	 */
	protected void sequence_AttributeTag(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Attribute
	 *     AbstractArtefact returns Attribute
	 *
	 * Constraint:
	 *     ((type=ValidString? value=QSTRING?) | value=ValidString)?
	 */
	protected void sequence_AttributeTag_IdRefTag(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributesCons returns Attribute
	 *
	 * Constraint:
	 *     (value=ValidString | type=ValidString)*
	 */
	protected void sequence_AttributesCons(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributesCons returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_AttributesCons(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributesConsAccess().getRefComponentValidStringParserRuleCall_1_1_1_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns BeforeAdvise
	 *     BeforeAdvise returns BeforeAdvise
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString)+
	 */
	protected void sequence_BeforeAdvise(ISerializationContext context, BeforeAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CNamespace returns Feature
	 *
	 * Constraint:
	 *     (name=ID (artefact=ReferenceComponent | artefact=AttributSimple))
	 */
	protected void sequence_CNamespace(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrFactory returns Class
	 *     Class returns Class
	 *
	 * Constraint:
	 *     classname=ValidString
	 */
	protected void sequence_Class(ISerializationContext context, org.xtext.spring.springConfigDsl.Class semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.CLASS__CLASSNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.CLASS__CLASSNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassAccess().getClassnameValidStringParserRuleCall_1_0(), semanticObject.getClassname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns ComponentScan
	 *     ContextType returns ComponentScan
	 *     ComponentScan returns ComponentScan
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             basePackage=ValidString | 
	 *             annotationConfig=sBoolean | 
	 *             nameGeneratorBean=[Component|ValidString] | 
	 *             resourcePattern=ValidString | 
	 *             scopeResolver=[Component|ValidString] | 
	 *             scopedProxy=EnumScopedProxy | 
	 *             useDefaultFilters=sBoolean
	 *         )* 
	 *         includeFilters+=IncludeFilter* 
	 *         excludeFilters+=ExcludeFilter*
	 *     )
	 */
	protected void sequence_ComponentScan(ISerializationContext context, ComponentScan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Component
	 *     AbstractArtefact returns Component
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name=ValidString | 
	 *             names+=ValidString | 
	 *             class=CreationMethod | 
	 *             features+=PNamespace | 
	 *             features+=CNamespace | 
	 *             abstract=sBoolean | 
	 *             autowireCandidate=DefaultableBoolean | 
	 *             autowire=DefaultableBoolean | 
	 *             dependsOn=[Component|ValidString] | 
	 *             detroyMethod=ValidString | 
	 *             initMethod=ValidString | 
	 *             lazyInit=DefaultableBoolean | 
	 *             parent=[Component|ValidString] | 
	 *             primary=sBoolean | 
	 *             scope=ValidString
	 *         )* 
	 *         description=Description? 
	 *         features+=Feature? 
	 *         (
	 *             (lookupMethods+=LookupMethod | qualifiers+=Qualifier | meta+=MetaTag | aopScopedProxy=AopScopedProxy | utilPropertiesPath+=UtilPropertyPath)? 
	 *             features+=Feature?
	 *         )*
	 *     )
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (
	 *         defaultAutowire=AutoWiredType? 
	 *         (
	 *             (
	 *                 defaultInitMethod=ValidString | 
	 *                 defaultAutowireCandidates=ValidString | 
	 *                 defaultDestroyMethod=ValidString | 
	 *                 defaultLazyInit=DefaultableBoolean | 
	 *                 defaultMerge=DefaultableBoolean | 
	 *                 profile=ValidString
	 *             )? 
	 *             defaultAutowire=AutoWiredType?
	 *         )* 
	 *         description=Description? 
	 *         (
	 *             components+=Component | 
	 *             alias+=Alias | 
	 *             imports+=Import | 
	 *             contexts+=Context | 
	 *             mvcs+=MVC | 
	 *             aspects+=Aspect | 
	 *             utilConstants+=UtilConstant | 
	 *             utilLists+=UtilList | 
	 *             utilMaps+=UtilMap | 
	 *             utilProperties+=UtilProperties | 
	 *             utilSets+=UtilSet | 
	 *             utilPropertiesPath+=UtilPropertyPath | 
	 *             txAdvices+=TxAdvise | 
	 *             txJtaTransactionManager+=TxJtaTransactionManager | 
	 *             txAnnotations+=TxAnnotation
	 *         )* 
	 *         ConfigurationComposite+=Configuration*
	 *     )
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorArgAtt returns Feature
	 *
	 * Constraint:
	 *     (index=ValidString | name=ValidString | artefact=AttributesCons)+
	 */
	protected void sequence_ConstructorArgAtt(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorArg returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ((index=ValidString | name=ValidString | type=ValidString)* description=Description? artefact=AbstractArtefact?) | 
	 *         ((index=ValidString | name=ValidString | artefact=AttributesCons)* description=Description?)
	 *     )
	 */
	protected void sequence_ConstructorArg_ConstructorArgAtt(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ((name=ValidString | artefact=ReferenceAtt | artefact=AttributeAtt)+ description=Description?) | 
	 *         (name=ValidString description=Description? artefact=AbstractArtefact?) | 
	 *         ((index=ValidString | name=ValidString | type=ValidString)* description=Description? artefact=AbstractArtefact?) | 
	 *         ((index=ValidString | name=ValidString | artefact=AttributesCons)* description=Description?)
	 *     )
	 */
	protected void sequence_ConstructorArg_ConstructorArgAtt_Property(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreationMethod returns CreationMethod
	 *
	 * Constraint:
	 *     (factoryMethod=ValidString | class=Class | class=Factory)+
	 */
	protected void sequence_CreationMethod(ISerializationContext context, CreationMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns DataString
	 *     DataString returns DataString
	 *
	 * Constraint:
	 *     s=ValidString
	 */
	protected void sequence_DataString(ISerializationContext context, DataString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.DATA_STRING__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.DATA_STRING__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataStringAccess().getSValidStringParserRuleCall_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclareParents returns DeclareParents
	 *
	 * Constraint:
	 *     (typeMatching=ValidString | implementInterface=AopImplInterface | defaultImplInterface=AopDefaultImplInterface | delegateImplRef=AopDelegateImplRef)+
	 */
	protected void sequence_DeclareParents(ISerializationContext context, DeclareParents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExcludeFilter returns ExcludeFilter
	 *
	 * Constraint:
	 *     (type=EnumTypeFilter | expression=ValidString)+
	 */
	protected void sequence_ExcludeFilter(ISerializationContext context, ExcludeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrFactory returns Factory
	 *     Factory returns Factory
	 *
	 * Constraint:
	 *     factoryBean=[Component|ValidString]
	 */
	protected void sequence_Factory(ISerializationContext context, Factory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.FACTORY__FACTORY_BEAN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.FACTORY__FACTORY_BEAN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactoryAccess().getFactoryBeanComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.FACTORY__FACTORY_BEAN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdRefTag returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_IdRefTag(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdRefTagAccess().getValueValidStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     resource=ValidString
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.IMPORT__RESOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.IMPORT__RESOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getResourceValidStringParserRuleCall_3_0(), semanticObject.getResource());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IncludeFilter returns IncludeFilter
	 *
	 * Constraint:
	 *     (type=EnumTypeFilter | expression=ValidString)+
	 */
	protected void sequence_IncludeFilter(ISerializationContext context, IncludeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Key
	 *
	 * Constraint:
	 *     (description=Description? key=AbstractArtefact?)
	 */
	protected void sequence_Key(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns LoadTimeWeaver
	 *     ContextType returns LoadTimeWeaver
	 *     LoadTimeWeaver returns LoadTimeWeaver
	 *
	 * Constraint:
	 *     (aspectjWeaving=ValidString | weaverClass=ValidString)*
	 */
	protected void sequence_LoadTimeWeaver(ISerializationContext context, LoadTimeWeaver semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupMethod returns LookupMethod
	 *
	 * Constraint:
	 *     (name=ValidString | ref=[Component|ValidString])+
	 */
	protected void sequence_LookupMethod(ISerializationContext context, LookupMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MVC returns MVC
	 *
	 * Constraint:
	 *     components+=Component+
	 */
	protected void sequence_MVC(ISerializationContext context, MVC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MVC returns PropertyFile
	 *
	 * Constraint:
	 *     (location=ValidString components+=Component*)
	 */
	protected void sequence_MVC_PropertyFileSimple(ISerializationContext context, PropertyFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryAtt returns MapEntry
	 *
	 * Constraint:
	 *     (((valueType=ValidString? key=MapEntryKeyAtt) | value=AttributSimpleValue | value=MapEntryValRef)+ description=Description?)
	 */
	protected void sequence_MapEntryAtt(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryKeyAtt returns Key
	 *
	 * Constraint:
	 *     (key=DataString | key=MapEntrykeyRef)
	 */
	protected void sequence_MapEntryKeyAtt(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryKey returns MapEntry
	 *
	 * Constraint:
	 *     ((valueType=ValidString | key=MapEntryKeyAtt)* description=Description? value=AbstractArtefact)
	 */
	protected void sequence_MapEntryKey(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryValRef returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_MapEntryValRef(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryValRefAccess().getRefComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryValue returns MapEntry
	 *
	 * Constraint:
	 *     ((valueType=ValidString | value=AttributSimpleValue | value=MapEntryValRef)* key=Key description=Description?)
	 */
	protected void sequence_MapEntryValue(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (
	 *         (key=Key value=AbstractArtefact? description=Description?) | 
	 *         ((valueType=ValidString | key=MapEntryKeyAtt)* description=Description? value=AbstractArtefact) | 
	 *         ((valueType=ValidString | value=AttributSimpleValue | value=MapEntryValRef)* key=Key description=Description?) | 
	 *         (((valueType=ValidString? key=MapEntryKeyAtt) | value=AttributSimpleValue | value=MapEntryValRef)+ description=Description?)
	 *     )
	 */
	protected void sequence_MapEntry_MapEntryAtt_MapEntryKey_MapEntryValue(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntrykeyRef returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_MapEntrykeyRef(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntrykeyRefAccess().getRefComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Map
	 *     AbstractArtefact returns Map
	 *     Collection returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     ((keyType=ValidString | merge=DefaultableBoolean | valueType=ValidString)* description=Description? entries+=MapEntry*)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns MbeanExport
	 *     ContextType returns MbeanExport
	 *     MbeanExport returns MbeanExport
	 *
	 * Constraint:
	 *     (defaultDomain=ValidString | registration=MbeanRegistrationEnum | server=[Component|ValidString])*
	 */
	protected void sequence_MbeanExport(ISerializationContext context, MbeanExport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns MbeanServer
	 *     ContextType returns MbeanServer
	 *     MbeanServer returns MbeanServer
	 *
	 * Constraint:
	 *     (agentId=ValidString | name=ValidString)*
	 */
	protected void sequence_MbeanServer(ISerializationContext context, MbeanServer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaTag returns Meta
	 *
	 * Constraint:
	 *     (key=ValidString | value=ValidString)+
	 */
	protected void sequence_MetaTag(ISerializationContext context, Meta semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PNamespace returns Feature
	 *
	 * Constraint:
	 *     (name=ID (artefact=ReferenceComponent | artefact=AttributSimple))
	 */
	protected void sequence_PNamespace(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PointCutExpression returns AopPointcut
	 *
	 * Constraint:
	 *     expression=ValidString
	 */
	protected void sequence_PointCutExpression(ISerializationContext context, AopPointcut semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.AOP_POINTCUT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.AOP_POINTCUT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointCutExpressionAccess().getExpressionValidStringParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Prop returns Prop
	 *
	 * Constraint:
	 *     (key=ValidString value=QSTRING)
	 */
	protected void sequence_Prop(ISerializationContext context, Prop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.PROP__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.PROP__KEY));
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.PROP__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.PROP__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropAccess().getKeyValidStringParserRuleCall_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getPropAccess().getValueQSTRINGParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyFileSimple returns PropertyFile
	 *
	 * Constraint:
	 *     location=ValidString
	 */
	protected void sequence_PropertyFileSimple(ISerializationContext context, PropertyFile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.PROPERTY_FILE__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.PROPERTY_FILE__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyFileSimpleAccess().getLocationValidStringParserRuleCall_1_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyFile returns PropertyFile
	 *
	 * Constraint:
	 *     (location=ValidString | fileEncoding=ValidString)+
	 */
	protected void sequence_PropertyFile(ISerializationContext context, PropertyFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns PropertyOverride
	 *     ContextType returns PropertyOverride
	 *     PropertyHolder returns PropertyOverride
	 *     PropertyOverride returns PropertyOverride
	 *
	 * Constraint:
	 *     (
	 *         propertyfile=PropertyFile | 
	 *         ignoreResourceNotFound=sBoolean | 
	 *         ignoreUnresolvable=sBoolean | 
	 *         localOverride=sBoolean | 
	 *         order=ValidString | 
	 *         propertiesRef=[Component|ValidString]
	 *     )+
	 */
	protected void sequence_PropertyOverride(ISerializationContext context, PropertyOverride semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns PropertyPlaceholder
	 *     ContextType returns PropertyPlaceholder
	 *     PropertyHolder returns PropertyPlaceholder
	 *     PropertyPlaceholder returns PropertyPlaceholder
	 *
	 * Constraint:
	 *     (
	 *         propertyfile=PropertyFile | 
	 *         ignoreResourceNotFound=sBoolean | 
	 *         ignoreUnresolvable=sBoolean | 
	 *         localOverride=sBoolean | 
	 *         order=ValidString | 
	 *         propertiesRef=[Component|ValidString] | 
	 *         systemPropertiesMode=ValidString
	 *     )+
	 */
	protected void sequence_PropertyPlaceholder(ISerializationContext context, PropertyPlaceholder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ((name=ValidString | artefact=ReferenceAtt | artefact=AttributeAtt)+ description=Description?) | 
	 *         (name=ValidString description=Description? artefact=AbstractArtefact?)
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Props
	 *     AbstractArtefact returns Props
	 *     Collection returns Props
	 *     Props returns Props
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? props+=Prop*)
	 */
	protected void sequence_Props(ISerializationContext context, Props semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualifierAttribute returns QualifierAttribute
	 *
	 * Constraint:
	 *     (key=ValidString | value=ValidString)+
	 */
	protected void sequence_QualifierAttribute(ISerializationContext context, QualifierAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Qualifier
	 *
	 * Constraint:
	 *     ((type=ValidString | value=ValidString)* qualifierAttributes+=QualifierAttribute*)
	 */
	protected void sequence_Qualifier(ISerializationContext context, Qualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceAtt returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_ReferenceAtt(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAttAccess().getRefComponentValidStringParserRuleCall_2_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceComponent returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_ReferenceComponent(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceComponentAccess().getRefComponentValidStringParserRuleCall_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Reference
	 *     AbstractArtefact returns Reference
	 *     ReferenceTag returns Reference
	 *
	 * Constraint:
	 *     ref=[AbstractArtefact|ValidString]
	 */
	protected void sequence_ReferenceTag(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceTagAccess().getRefAbstractArtefactValidStringParserRuleCall_3_0_1(), semanticObject.eGet(SpringConfigDslPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns SpringConfigured
	 *     ContextType returns SpringConfigured
	 *     SpringConfigured returns SpringConfigured
	 *
	 * Constraint:
	 *     {SpringConfigured}
	 */
	protected void sequence_SpringConfigured(ISerializationContext context, SpringConfigured semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpringProject returns SpringProject
	 *
	 * Constraint:
	 *     configurations+=Configuration
	 */
	protected void sequence_SpringProject(ISerializationContext context, SpringProject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxAdvise returns TxAdvise
	 *
	 * Constraint:
	 *     ((name=ValidString | transactionManager=ValidString)* txAttribute=TxAttribute?)
	 */
	protected void sequence_TxAdvise(ISerializationContext context, TxAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxAnnotation returns TxAnnotation
	 *
	 * Constraint:
	 *     transactionManager=ValidString
	 */
	protected void sequence_TxAnnotation(ISerializationContext context, TxAnnotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringConfigDslPackage.Literals.TX_ANNOTATION__TRANSACTION_MANAGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringConfigDslPackage.Literals.TX_ANNOTATION__TRANSACTION_MANAGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTxAnnotationAccess().getTransactionManagerValidStringParserRuleCall_1_1_0(), semanticObject.getTransactionManager());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TxAttribute returns TxAttribute
	 *
	 * Constraint:
	 *     txMethods+=TxMethod+
	 */
	protected void sequence_TxAttribute(ISerializationContext context, TxAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxJtaTransactionManager returns TxJtaTransactionManager
	 *
	 * Constraint:
	 *     {TxJtaTransactionManager}
	 */
	protected void sequence_TxJtaTransactionManager(ISerializationContext context, TxJtaTransactionManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxMethod returns TxMethod
	 *
	 * Constraint:
	 *     (
	 *         name=ValidString | 
	 *         isolation=EnumIsolation | 
	 *         noRollBackFor=ValidString | 
	 *         propagation=EnumIsolation | 
	 *         readOnly=sBoolean | 
	 *         rollbackFor=ValidString | 
	 *         timeOut=ValidString
	 *     )+
	 */
	protected void sequence_TxMethod(ISerializationContext context, TxMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilConstant
	 *     AbstractArtefact returns UtilConstant
	 *     AttributeTag returns UtilConstant
	 *     UtilConstant returns UtilConstant
	 *
	 * Constraint:
	 *     (StaticField=STRING | name=ValidString)*
	 */
	protected void sequence_UtilConstant(ISerializationContext context, UtilConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilList
	 *     AbstractArtefact returns UtilList
	 *     Collection returns UtilList
	 *     sList returns UtilList
	 *     UtilList returns UtilList
	 *
	 * Constraint:
	 *     ((name=ValidString | listClass=ValidString | scope=ValidString | valueType=ValidString)* artefacts+=AbstractArtefact*)
	 */
	protected void sequence_UtilList(ISerializationContext context, UtilList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilMap
	 *     AbstractArtefact returns UtilMap
	 *     Collection returns UtilMap
	 *     Map returns UtilMap
	 *     UtilMap returns UtilMap
	 *
	 * Constraint:
	 *     ((name=ValidString | keyType=ValidString | mapClass=ValidString | scope=ValidString | valueType=ValidString)* entries+=MapEntry*)
	 */
	protected void sequence_UtilMap(ISerializationContext context, UtilMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilProperties
	 *     AbstractArtefact returns UtilProperties
	 *     Collection returns UtilProperties
	 *     Props returns UtilProperties
	 *     UtilProperties returns UtilProperties
	 *
	 * Constraint:
	 *     (
	 *         propertyfile=PropertyFileSimple | 
	 *         name=ValidString | 
	 *         ignoreResourceNotFound=sBoolean | 
	 *         localOverride=sBoolean | 
	 *         scope=ValidString | 
	 *         valueType=ValidString | 
	 *         props+=Prop
	 *     )*
	 */
	protected void sequence_UtilProperties(ISerializationContext context, UtilProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UtilPropertyPath returns UtilPropertyPath
	 *
	 * Constraint:
	 *     (name=ValidString | path=ValidString)+
	 */
	protected void sequence_UtilPropertyPath(ISerializationContext context, UtilPropertyPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilSet
	 *     AbstractArtefact returns UtilSet
	 *     Collection returns UtilSet
	 *     sSet returns UtilSet
	 *     UtilSet returns UtilSet
	 *
	 * Constraint:
	 *     ((name=ValidString | setClass=ValidString | scope=ValidString | valueType=ValidString)* artefacts+=AbstractArtefact*)
	 */
	protected void sequence_UtilSet(ISerializationContext context, UtilSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns sList
	 *     AbstractArtefact returns sList
	 *     Collection returns sList
	 *     sList returns sList
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? artefacts+=AbstractArtefact*)
	 */
	protected void sequence_sList(ISerializationContext context, sList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns sSet
	 *     AbstractArtefact returns sSet
	 *     Collection returns sSet
	 *     sSet returns sSet
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? artefacts+=AbstractArtefact*)
	 */
	protected void sequence_sSet(ISerializationContext context, sSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
