/*
 * generated by Xtext 2.18.0
 */
package fr.imt.ales.springdsl.serializer;

import com.google.inject.Inject;
import fr.imt.ales.springdsl.services.SpringDSLGrammarAccess;
import fr.imt.ales.springdsl.springDSL.AfterAdvise;
import fr.imt.ales.springdsl.springDSL.AfterReturning;
import fr.imt.ales.springdsl.springDSL.AfterThowing;
import fr.imt.ales.springdsl.springDSL.Alias;
import fr.imt.ales.springdsl.springDSL.AnnotationConfig;
import fr.imt.ales.springdsl.springDSL.AopAdvisor;
import fr.imt.ales.springdsl.springDSL.AopAspect;
import fr.imt.ales.springdsl.springDSL.AopAspectJAutoproxy;
import fr.imt.ales.springdsl.springDSL.AopConfig;
import fr.imt.ales.springdsl.springDSL.AopDefaultImplInterface;
import fr.imt.ales.springdsl.springDSL.AopDelegateImplRef;
import fr.imt.ales.springdsl.springDSL.AopInclude;
import fr.imt.ales.springdsl.springDSL.AopPointcut;
import fr.imt.ales.springdsl.springDSL.AopScopedProxy;
import fr.imt.ales.springdsl.springDSL.AroundAdvise;
import fr.imt.ales.springdsl.springDSL.Array;
import fr.imt.ales.springdsl.springDSL.Attribute;
import fr.imt.ales.springdsl.springDSL.BeforeAdvise;
import fr.imt.ales.springdsl.springDSL.Component;
import fr.imt.ales.springdsl.springDSL.ComponentScan;
import fr.imt.ales.springdsl.springDSL.Configuration;
import fr.imt.ales.springdsl.springDSL.CreationMethod;
import fr.imt.ales.springdsl.springDSL.DataString;
import fr.imt.ales.springdsl.springDSL.DeclareParents;
import fr.imt.ales.springdsl.springDSL.ExcludeFilter;
import fr.imt.ales.springdsl.springDSL.Factory;
import fr.imt.ales.springdsl.springDSL.Feature;
import fr.imt.ales.springdsl.springDSL.Import;
import fr.imt.ales.springdsl.springDSL.IncludeFilter;
import fr.imt.ales.springdsl.springDSL.Interface;
import fr.imt.ales.springdsl.springDSL.Key;
import fr.imt.ales.springdsl.springDSL.LoadTimeWeaver;
import fr.imt.ales.springdsl.springDSL.LookupMethod;
import fr.imt.ales.springdsl.springDSL.MVC;
import fr.imt.ales.springdsl.springDSL.Map;
import fr.imt.ales.springdsl.springDSL.MapEntry;
import fr.imt.ales.springdsl.springDSL.MbeanExport;
import fr.imt.ales.springdsl.springDSL.MbeanServer;
import fr.imt.ales.springdsl.springDSL.Meta;
import fr.imt.ales.springdsl.springDSL.Prop;
import fr.imt.ales.springdsl.springDSL.PropertyFile;
import fr.imt.ales.springdsl.springDSL.PropertyOverride;
import fr.imt.ales.springdsl.springDSL.PropertyPlaceholder;
import fr.imt.ales.springdsl.springDSL.Props;
import fr.imt.ales.springdsl.springDSL.Qualifier;
import fr.imt.ales.springdsl.springDSL.QualifierAttribute;
import fr.imt.ales.springdsl.springDSL.Reference;
import fr.imt.ales.springdsl.springDSL.SpringConfigured;
import fr.imt.ales.springdsl.springDSL.SpringDSLPackage;
import fr.imt.ales.springdsl.springDSL.SpringProject;
import fr.imt.ales.springdsl.springDSL.TxAdvise;
import fr.imt.ales.springdsl.springDSL.TxAttribute;
import fr.imt.ales.springdsl.springDSL.TxJtaTransactionManager;
import fr.imt.ales.springdsl.springDSL.TxMethod;
import fr.imt.ales.springdsl.springDSL.UtilConstant;
import fr.imt.ales.springdsl.springDSL.UtilList;
import fr.imt.ales.springdsl.springDSL.UtilMap;
import fr.imt.ales.springdsl.springDSL.UtilProperties;
import fr.imt.ales.springdsl.springDSL.UtilPropertyPath;
import fr.imt.ales.springdsl.springDSL.UtilSet;
import fr.imt.ales.springdsl.springDSL.sList;
import fr.imt.ales.springdsl.springDSL.sSet;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SpringDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpringDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpringDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpringDSLPackage.AFTER_ADVISE:
				sequence_AfterAdvise(context, (AfterAdvise) semanticObject); 
				return; 
			case SpringDSLPackage.AFTER_RETURNING:
				sequence_AfterReturning(context, (AfterReturning) semanticObject); 
				return; 
			case SpringDSLPackage.AFTER_THOWING:
				sequence_AfterThowing(context, (AfterThowing) semanticObject); 
				return; 
			case SpringDSLPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case SpringDSLPackage.ANNOTATION_CONFIG:
				sequence_AnnotationConfig(context, (AnnotationConfig) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_ADVISOR:
				sequence_AopAdvisor(context, (AopAdvisor) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_ASPECT:
				sequence_AopAspect(context, (AopAspect) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_ASPECT_JAUTOPROXY:
				sequence_AopAspectJAutoproxy(context, (AopAspectJAutoproxy) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_CONFIG:
				sequence_AopConfig(context, (AopConfig) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_DEFAULT_IMPL_INTERFACE:
				sequence_AopDefaultImplInterface(context, (AopDefaultImplInterface) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_DELEGATE_IMPL_REF:
				sequence_AopDelegateImplRef(context, (AopDelegateImplRef) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_INCLUDE:
				sequence_AopInclude(context, (AopInclude) semanticObject); 
				return; 
			case SpringDSLPackage.AOP_POINTCUT:
				if (rule == grammarAccess.getAopPointcutRule()) {
					sequence_AopPointcut(context, (AopPointcut) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPointCutExpressionRule()) {
					sequence_PointCutExpression(context, (AopPointcut) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.AOP_SCOPED_PROXY:
				sequence_AopScopedProxy(context, (AopScopedProxy) semanticObject); 
				return; 
			case SpringDSLPackage.AROUND_ADVISE:
				sequence_AroundAdvise(context, (AroundAdvise) semanticObject); 
				return; 
			case SpringDSLPackage.ARRAY:
				sequence_Array(context, (Array) semanticObject); 
				return; 
			case SpringDSLPackage.ATTRIBUTE:
				if (rule == grammarAccess.getAttributSimpleValueRule()) {
					sequence_AttributSimpleValue(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributSimpleRule()) {
					sequence_AttributSimple(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeAttRule()) {
					sequence_AttributeAtt(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeTagRule()) {
					sequence_AttributeTag(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractKeyValueRule()
						|| rule == grammarAccess.getAbstractArtefactRule()) {
					sequence_AttributeTag_IdRefTag(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributesConsRule()) {
					sequence_AttributesCons(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIdRefTagRule()) {
					sequence_IdRefTag(context, (Attribute) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.BEFORE_ADVISE:
				sequence_BeforeAdvise(context, (BeforeAdvise) semanticObject); 
				return; 
			case SpringDSLPackage.CLASS:
				sequence_Class(context, (fr.imt.ales.springdsl.springDSL.Class) semanticObject); 
				return; 
			case SpringDSLPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case SpringDSLPackage.COMPONENT_SCAN:
				sequence_ComponentScan(context, (ComponentScan) semanticObject); 
				return; 
			case SpringDSLPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case SpringDSLPackage.CREATION_METHOD:
				sequence_CreationMethod(context, (CreationMethod) semanticObject); 
				return; 
			case SpringDSLPackage.DATA_STRING:
				sequence_DataString(context, (DataString) semanticObject); 
				return; 
			case SpringDSLPackage.DECLARE_PARENTS:
				sequence_DeclareParents(context, (DeclareParents) semanticObject); 
				return; 
			case SpringDSLPackage.EXCLUDE_FILTER:
				sequence_ExcludeFilter(context, (ExcludeFilter) semanticObject); 
				return; 
			case SpringDSLPackage.FACTORY:
				sequence_Factory(context, (Factory) semanticObject); 
				return; 
			case SpringDSLPackage.FEATURE:
				if (rule == grammarAccess.getCNamespaceRule()) {
					sequence_CNamespace(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstructorArgAttRule()) {
					sequence_ConstructorArgAtt(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstructorArgRule()) {
					sequence_ConstructorArg_ConstructorArgAtt(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureRule()) {
					sequence_ConstructorArg_ConstructorArgAtt_Property(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPNamespaceRule()) {
					sequence_PNamespace(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyRule()) {
					sequence_Property(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SpringDSLPackage.INCLUDE_FILTER:
				sequence_IncludeFilter(context, (IncludeFilter) semanticObject); 
				return; 
			case SpringDSLPackage.INTERFACE:
				sequence_AopImplInterface(context, (Interface) semanticObject); 
				return; 
			case SpringDSLPackage.KEY:
				if (rule == grammarAccess.getKeyRule()) {
					sequence_Key(context, (Key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryKeyAttRule()) {
					sequence_MapEntryKeyAtt(context, (Key) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.LOAD_TIME_WEAVER:
				sequence_LoadTimeWeaver(context, (LoadTimeWeaver) semanticObject); 
				return; 
			case SpringDSLPackage.LOOKUP_METHOD:
				sequence_LookupMethod(context, (LookupMethod) semanticObject); 
				return; 
			case SpringDSLPackage.MVC:
				sequence_MVC(context, (MVC) semanticObject); 
				return; 
			case SpringDSLPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case SpringDSLPackage.MAP_ENTRY:
				if (rule == grammarAccess.getMapEntryAttRule()) {
					sequence_MapEntryAtt(context, (MapEntry) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryKeyRule()) {
					sequence_MapEntryKey(context, (MapEntry) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryValueRule()) {
					sequence_MapEntryValue(context, (MapEntry) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryRule()) {
					sequence_MapEntry_MapEntryAtt_MapEntryKey_MapEntryValue(context, (MapEntry) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.MBEAN_EXPORT:
				sequence_MbeanExport(context, (MbeanExport) semanticObject); 
				return; 
			case SpringDSLPackage.MBEAN_SERVER:
				sequence_MbeanServer(context, (MbeanServer) semanticObject); 
				return; 
			case SpringDSLPackage.META:
				sequence_MetaTag(context, (Meta) semanticObject); 
				return; 
			case SpringDSLPackage.PROP:
				sequence_Prop(context, (Prop) semanticObject); 
				return; 
			case SpringDSLPackage.PROPERTY_FILE:
				if (rule == grammarAccess.getPropertyFileSimpleRule()) {
					sequence_PropertyFileSimple(context, (PropertyFile) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyFileRule()) {
					sequence_PropertyFile(context, (PropertyFile) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.PROPERTY_OVERRIDE:
				sequence_PropertyOverride(context, (PropertyOverride) semanticObject); 
				return; 
			case SpringDSLPackage.PROPERTY_PLACEHOLDER:
				sequence_PropertyPlaceholder(context, (PropertyPlaceholder) semanticObject); 
				return; 
			case SpringDSLPackage.PROPS:
				sequence_Props(context, (Props) semanticObject); 
				return; 
			case SpringDSLPackage.QUALIFIER:
				sequence_Qualifier(context, (Qualifier) semanticObject); 
				return; 
			case SpringDSLPackage.QUALIFIER_ATTRIBUTE:
				sequence_QualifierAttribute(context, (QualifierAttribute) semanticObject); 
				return; 
			case SpringDSLPackage.REFERENCE:
				if (rule == grammarAccess.getAttributesConsRule()) {
					sequence_AttributesCons(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntryValRefRule()) {
					sequence_MapEntryValRef(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapEntrykeyRefRule()) {
					sequence_MapEntrykeyRef(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReferenceAttRule()) {
					sequence_ReferenceAtt(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReferenceComponentRule()) {
					sequence_ReferenceComponent(context, (Reference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractKeyValueRule()
						|| rule == grammarAccess.getAbstractArtefactRule()
						|| rule == grammarAccess.getReferenceTagRule()) {
					sequence_ReferenceTag(context, (Reference) semanticObject); 
					return; 
				}
				else break;
			case SpringDSLPackage.SPRING_CONFIGURED:
				sequence_SpringConfigured(context, (SpringConfigured) semanticObject); 
				return; 
			case SpringDSLPackage.SPRING_PROJECT:
				sequence_SpringProject(context, (SpringProject) semanticObject); 
				return; 
			case SpringDSLPackage.TX_ADVISE:
				sequence_TxAdvise(context, (TxAdvise) semanticObject); 
				return; 
			case SpringDSLPackage.TX_ATTRIBUTE:
				sequence_TxAttribute(context, (TxAttribute) semanticObject); 
				return; 
			case SpringDSLPackage.TX_JTA_TRANSACTION_MANAGER:
				sequence_TxJtaTransactionManager(context, (TxJtaTransactionManager) semanticObject); 
				return; 
			case SpringDSLPackage.TX_METHOD:
				sequence_TxMethod(context, (TxMethod) semanticObject); 
				return; 
			case SpringDSLPackage.UTIL_CONSTANT:
				sequence_UtilConstant(context, (UtilConstant) semanticObject); 
				return; 
			case SpringDSLPackage.UTIL_LIST:
				sequence_UtilList(context, (UtilList) semanticObject); 
				return; 
			case SpringDSLPackage.UTIL_MAP:
				sequence_UtilMap(context, (UtilMap) semanticObject); 
				return; 
			case SpringDSLPackage.UTIL_PROPERTIES:
				sequence_UtilProperties(context, (UtilProperties) semanticObject); 
				return; 
			case SpringDSLPackage.UTIL_PROPERTY_PATH:
				sequence_UtilPropertyPath(context, (UtilPropertyPath) semanticObject); 
				return; 
			case SpringDSLPackage.UTIL_SET:
				sequence_UtilSet(context, (UtilSet) semanticObject); 
				return; 
			case SpringDSLPackage.SLIST:
				sequence_sList(context, (sList) semanticObject); 
				return; 
			case SpringDSLPackage.SSET:
				sequence_sSet(context, (sSet) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Advise returns AfterAdvise
	 *     AfterAdvise returns AfterAdvise
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString)+
	 */
	protected void sequence_AfterAdvise(ISerializationContext context, AfterAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns AfterReturning
	 *     AfterReturning returns AfterReturning
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString | returningValue=ValidString)+
	 */
	protected void sequence_AfterReturning(ISerializationContext context, AfterReturning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns AfterThowing
	 *     AfterThowing returns AfterThowing
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString | throwingValue=ValidString)+
	 */
	protected void sequence_AfterThowing(ISerializationContext context, AfterThowing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     (origin=[Component|ValidString] alias=ValidString)
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.ALIAS__ORIGIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.ALIAS__ORIGIN));
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.ALIAS__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.ALIAS__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasAccess().getOriginComponentValidStringParserRuleCall_3_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.ALIAS__ORIGIN, false));
		feeder.accept(grammarAccess.getAliasAccess().getAliasValidStringParserRuleCall_5_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns AnnotationConfig
	 *     ContextType returns AnnotationConfig
	 *     AnnotationConfig returns AnnotationConfig
	 *
	 * Constraint:
	 *     {AnnotationConfig}
	 */
	protected void sequence_AnnotationConfig(ISerializationContext context, AnnotationConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopAdvisor returns AopAdvisor
	 *
	 * Constraint:
	 *     (adviceRef=[TxAdvise|ValidString] | name=ValidString | order=ValidString | pointcut=PointCutExpression | pointcutRef=[AopPointcut|ValidString])+
	 */
	protected void sequence_AopAdvisor(ISerializationContext context, AopAdvisor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aspect returns AopAspectJAutoproxy
	 *     AspectType returns AopAspectJAutoproxy
	 *     AopAspectJAutoproxy returns AopAspectJAutoproxy
	 *
	 * Constraint:
	 *     ((exposeProxy=sBoolean | proxyTrajetClass=sBoolean)* aopincludes+=AopInclude*)
	 */
	protected void sequence_AopAspectJAutoproxy(ISerializationContext context, AopAspectJAutoproxy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopAspect returns AopAspect
	 *
	 * Constraint:
	 *     (
	 *         (name=ValidString | order=ValidString | backingBeanRef=[Component|ValidString])+ 
	 *         aopPointcuts+=AopPointcut? 
	 *         ((declaredParents+=DeclareParents | advises+=Advise)? aopPointcuts+=AopPointcut?)*
	 *     )
	 */
	protected void sequence_AopAspect(ISerializationContext context, AopAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aspect returns AopConfig
	 *     AspectType returns AopConfig
	 *     AopConfig returns AopConfig
	 *
	 * Constraint:
	 *     ((exposeProxy=sBoolean | proxyTrajetClass=sBoolean)* aopPointcuts+=AopPointcut* aopAdvisors+=AopAdvisor* aspects+=AopAspect*)
	 */
	protected void sequence_AopConfig(ISerializationContext context, AopConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopDefaultImplInterface returns AopDefaultImplInterface
	 *
	 * Constraint:
	 *     name=ValidString
	 */
	protected void sequence_AopDefaultImplInterface(ISerializationContext context, AopDefaultImplInterface semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.AOP_DEFAULT_IMPL_INTERFACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.AOP_DEFAULT_IMPL_INTERFACE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopDefaultImplInterfaceAccess().getNameValidStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopDelegateImplRef returns AopDelegateImplRef
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_AopDelegateImplRef(ISerializationContext context, AopDelegateImplRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.AOP_DELEGATE_IMPL_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.AOP_DELEGATE_IMPL_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopDelegateImplRefAccess().getRefComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.AOP_DELEGATE_IMPL_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopImplInterface returns Interface
	 *
	 * Constraint:
	 *     name=ValidString
	 */
	protected void sequence_AopImplInterface(ISerializationContext context, Interface semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.INTERFACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.INTERFACE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopImplInterfaceAccess().getNameValidStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopInclude returns AopInclude
	 *
	 * Constraint:
	 *     aopInclude=[Component|ValidString]
	 */
	protected void sequence_AopInclude(ISerializationContext context, AopInclude semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.AOP_INCLUDE__AOP_INCLUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.AOP_INCLUDE__AOP_INCLUDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAopIncludeAccess().getAopIncludeComponentValidStringParserRuleCall_2_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.AOP_INCLUDE__AOP_INCLUDE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AopPointcut returns AopPointcut
	 *
	 * Constraint:
	 *     (expression=ValidString | name=ValidString)+
	 */
	protected void sequence_AopPointcut(ISerializationContext context, AopPointcut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AopScopedProxy returns AopScopedProxy
	 *
	 * Constraint:
	 *     proxyTargetClass=ValidString?
	 */
	protected void sequence_AopScopedProxy(ISerializationContext context, AopScopedProxy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns AroundAdvise
	 *     AroundAdvise returns AroundAdvise
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString)+
	 */
	protected void sequence_AroundAdvise(ISerializationContext context, AroundAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Array
	 *     AbstractArtefact returns Array
	 *     Collection returns Array
	 *     Array returns Array
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? artefacts+=AbstractArtefact*)
	 */
	protected void sequence_Array(ISerializationContext context, Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributSimpleValue returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_AttributSimpleValue(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributSimpleValueAccess().getValueValidStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributSimple returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_AttributSimple(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributSimpleAccess().getValueValidStringParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeAtt returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_AttributeAtt(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAttAccess().getValueValidStringParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeTag returns Attribute
	 *
	 * Constraint:
	 *     (type=ValidString? value=QSTRING?)
	 */
	protected void sequence_AttributeTag(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Attribute
	 *     AbstractArtefact returns Attribute
	 *
	 * Constraint:
	 *     ((type=ValidString? value=QSTRING?) | value=ValidString)?
	 */
	protected void sequence_AttributeTag_IdRefTag(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributesCons returns Attribute
	 *
	 * Constraint:
	 *     (value=ValidString | type=ValidString)*
	 */
	protected void sequence_AttributesCons(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributesCons returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_AttributesCons(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributesConsAccess().getRefComponentValidStringParserRuleCall_1_1_1_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Advise returns BeforeAdvise
	 *     BeforeAdvise returns BeforeAdvise
	 *
	 * Constraint:
	 *     (pointcutRef=[AopPointcut|ValidString] | PointcutExpression=ValidString | method=ValidString)+
	 */
	protected void sequence_BeforeAdvise(ISerializationContext context, BeforeAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CNamespace returns Feature
	 *
	 * Constraint:
	 *     (name=ID (artefact=ReferenceComponent | artefact=AttributSimple))
	 */
	protected void sequence_CNamespace(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrFactory returns Class
	 *     Class returns Class
	 *
	 * Constraint:
	 *     classname=ValidString
	 */
	protected void sequence_Class(ISerializationContext context, fr.imt.ales.springdsl.springDSL.Class semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.CLASS__CLASSNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.CLASS__CLASSNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassAccess().getClassnameValidStringParserRuleCall_1_0(), semanticObject.getClassname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns ComponentScan
	 *     ContextType returns ComponentScan
	 *     ComponentScan returns ComponentScan
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             basePackage=ValidString | 
	 *             annotationConfig=sBoolean | 
	 *             nameGeneratorBean=[Component|ValidString] | 
	 *             resourcePattern=ValidString | 
	 *             scopeResolver=[Component|ValidString] | 
	 *             scopedProxy=EnumScopedProxy | 
	 *             useDefaultFilters=sBoolean
	 *         )* 
	 *         includeFilters+=IncludeFilter* 
	 *         excludeFilters+=ExcludeFilter*
	 *     )
	 */
	protected void sequence_ComponentScan(ISerializationContext context, ComponentScan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Component
	 *     AbstractArtefact returns Component
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name=ValidString | 
	 *             names+=ValidString | 
	 *             class=CreationMethod | 
	 *             features+=PNamespace | 
	 *             features+=CNamespace | 
	 *             abstract=sBoolean | 
	 *             autowireCandidate=DefaultableBoolean | 
	 *             autowire=DefaultableBoolean | 
	 *             dependsOn=[Component|ValidString] | 
	 *             detroyMethod=ValidString | 
	 *             initMethod=ValidString | 
	 *             lazyInit=DefaultableBoolean | 
	 *             parent=[Component|ValidString] | 
	 *             primary=sBoolean | 
	 *             scope=ValidString
	 *         )* 
	 *         description=Description? 
	 *         aopScopedProxy=AopScopedProxy? 
	 *         (
	 *             (features+=Feature | lookupMethods+=LookupMethod | qualifiers+=Qualifier | meta+=MetaTag | utilPropertiesPath+=UtilPropertyPath)? 
	 *             aopScopedProxy=AopScopedProxy?
	 *         )*
	 *     )
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             defaultAutowire=AutoWiredType | 
	 *             defaultInitMethod=ValidString | 
	 *             defaultAutowireCandidates=ValidString | 
	 *             defaultDestroyMethod=ValidString | 
	 *             defaultLazyInit=DefaultableBoolean | 
	 *             defaultMerge=DefaultableBoolean | 
	 *             profile=ValidString
	 *         )* 
	 *         description=Description? 
	 *         components+=Component? 
	 *         (
	 *             (
	 *                 alias+=Alias | 
	 *                 imports+=Import | 
	 *                 contexts+=Context | 
	 *                 mvcs+=MVC | 
	 *                 aspects+=Aspect | 
	 *                 utilConstants+=UtilConstant | 
	 *                 utilLists+=UtilList | 
	 *                 utilMaps+=UtilMap | 
	 *                 utilProperties+=UtilProperties | 
	 *                 utilSets+=UtilSet | 
	 *                 utilPropertiesPath+=UtilPropertyPath | 
	 *                 txAdvices+=TxAdvise | 
	 *                 txJtaTransactionManager+=TxJtaTransactionManager
	 *             )? 
	 *             components+=Component?
	 *         )* 
	 *         ConfigurationComposite+=Configuration*
	 *     )
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorArgAtt returns Feature
	 *
	 * Constraint:
	 *     (index=ValidString | name=ValidString | artefact=AttributesCons)+
	 */
	protected void sequence_ConstructorArgAtt(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorArg returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ((index=ValidString | name=ValidString | type=ValidString)* description=Description? artefact=AbstractArtefact?) | 
	 *         ((index=ValidString | name=ValidString | artefact=AttributesCons)* description=Description?)
	 *     )
	 */
	protected void sequence_ConstructorArg_ConstructorArgAtt(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ((name=ValidString | artefact=ReferenceAtt | artefact=AttributeAtt)+ description=Description?) | 
	 *         (name=ValidString description=Description? artefact=AbstractArtefact?) | 
	 *         ((index=ValidString | name=ValidString | type=ValidString)* description=Description? artefact=AbstractArtefact?) | 
	 *         ((index=ValidString | name=ValidString | artefact=AttributesCons)* description=Description?)
	 *     )
	 */
	protected void sequence_ConstructorArg_ConstructorArgAtt_Property(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreationMethod returns CreationMethod
	 *
	 * Constraint:
	 *     (factoryMethod=ValidString | class=Class | class=Factory)+
	 */
	protected void sequence_CreationMethod(ISerializationContext context, CreationMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns DataString
	 *     DataString returns DataString
	 *
	 * Constraint:
	 *     s=ValidString
	 */
	protected void sequence_DataString(ISerializationContext context, DataString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.DATA_STRING__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.DATA_STRING__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataStringAccess().getSValidStringParserRuleCall_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclareParents returns DeclareParents
	 *
	 * Constraint:
	 *     (typeMatching=ValidString | implementInterface=AopImplInterface | defaultImplInterface=AopDefaultImplInterface | delegateImplRef=AopDelegateImplRef)+
	 */
	protected void sequence_DeclareParents(ISerializationContext context, DeclareParents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExcludeFilter returns ExcludeFilter
	 *
	 * Constraint:
	 *     (type=EnumTypeFilter | expression=ValidString)+
	 */
	protected void sequence_ExcludeFilter(ISerializationContext context, ExcludeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrFactory returns Factory
	 *     Factory returns Factory
	 *
	 * Constraint:
	 *     factoryBean=[Component|ValidString]
	 */
	protected void sequence_Factory(ISerializationContext context, Factory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.FACTORY__FACTORY_BEAN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.FACTORY__FACTORY_BEAN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactoryAccess().getFactoryBeanComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.FACTORY__FACTORY_BEAN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdRefTag returns Attribute
	 *
	 * Constraint:
	 *     value=ValidString
	 */
	protected void sequence_IdRefTag(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdRefTagAccess().getValueValidStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     resource=ValidString
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.IMPORT__RESOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.IMPORT__RESOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getResourceValidStringParserRuleCall_3_0(), semanticObject.getResource());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IncludeFilter returns IncludeFilter
	 *
	 * Constraint:
	 *     (type=EnumTypeFilter | expression=ValidString)+
	 */
	protected void sequence_IncludeFilter(ISerializationContext context, IncludeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Key
	 *
	 * Constraint:
	 *     (description=Description? key=AbstractArtefact?)
	 */
	protected void sequence_Key(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns LoadTimeWeaver
	 *     ContextType returns LoadTimeWeaver
	 *     LoadTimeWeaver returns LoadTimeWeaver
	 *
	 * Constraint:
	 *     (aspectjWeaving=ValidString | weaverClass=ValidString)*
	 */
	protected void sequence_LoadTimeWeaver(ISerializationContext context, LoadTimeWeaver semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupMethod returns LookupMethod
	 *
	 * Constraint:
	 *     (name=ValidString | ref=[Component|ValidString])+
	 */
	protected void sequence_LookupMethod(ISerializationContext context, LookupMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MVC returns MVC
	 *
	 * Constraint:
	 *     {MVC}
	 */
	protected void sequence_MVC(ISerializationContext context, MVC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryAtt returns MapEntry
	 *
	 * Constraint:
	 *     (((valueType=ValidString? key=MapEntryKeyAtt) | value=AttributSimpleValue | value=MapEntryValRef)+ description=Description?)
	 */
	protected void sequence_MapEntryAtt(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryKeyAtt returns Key
	 *
	 * Constraint:
	 *     (key=DataString | key=MapEntrykeyRef)
	 */
	protected void sequence_MapEntryKeyAtt(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryKey returns MapEntry
	 *
	 * Constraint:
	 *     ((valueType=ValidString | key=MapEntryKeyAtt)* description=Description? value=AbstractArtefact)
	 */
	protected void sequence_MapEntryKey(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryValRef returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_MapEntryValRef(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryValRefAccess().getRefComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryValue returns MapEntry
	 *
	 * Constraint:
	 *     ((valueType=ValidString | value=AttributSimpleValue | value=MapEntryValRef)* key=Key description=Description?)
	 */
	protected void sequence_MapEntryValue(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (
	 *         (key=Key value=AbstractArtefact? description=Description?) | 
	 *         ((valueType=ValidString | key=MapEntryKeyAtt)* description=Description? value=AbstractArtefact) | 
	 *         ((valueType=ValidString | value=AttributSimpleValue | value=MapEntryValRef)* key=Key description=Description?) | 
	 *         (((valueType=ValidString? key=MapEntryKeyAtt) | value=AttributSimpleValue | value=MapEntryValRef)+ description=Description?)
	 *     )
	 */
	protected void sequence_MapEntry_MapEntryAtt_MapEntryKey_MapEntryValue(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntrykeyRef returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_MapEntrykeyRef(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntrykeyRefAccess().getRefComponentValidStringParserRuleCall_1_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Map
	 *     AbstractArtefact returns Map
	 *     Collection returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     ((keyType=ValidString | merge=DefaultableBoolean | valueType=ValidString)* description=Description? entries+=MapEntry*)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns MbeanExport
	 *     ContextType returns MbeanExport
	 *     MbeanExport returns MbeanExport
	 *
	 * Constraint:
	 *     (defaultDomain=ValidString | registration=MbeanRegistrationEnum | server=[Component|ValidString])*
	 */
	protected void sequence_MbeanExport(ISerializationContext context, MbeanExport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns MbeanServer
	 *     ContextType returns MbeanServer
	 *     MbeanServer returns MbeanServer
	 *
	 * Constraint:
	 *     (agentId=ValidString | name=ValidString)*
	 */
	protected void sequence_MbeanServer(ISerializationContext context, MbeanServer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaTag returns Meta
	 *
	 * Constraint:
	 *     (key=ValidString | value=ValidString)+
	 */
	protected void sequence_MetaTag(ISerializationContext context, Meta semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PNamespace returns Feature
	 *
	 * Constraint:
	 *     (name=ID (artefact=ReferenceComponent | artefact=AttributSimple))
	 */
	protected void sequence_PNamespace(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PointCutExpression returns AopPointcut
	 *
	 * Constraint:
	 *     expression=ValidString
	 */
	protected void sequence_PointCutExpression(ISerializationContext context, AopPointcut semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.AOP_POINTCUT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.AOP_POINTCUT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointCutExpressionAccess().getExpressionValidStringParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Prop returns Prop
	 *
	 * Constraint:
	 *     (key=ValidString value=QSTRING)
	 */
	protected void sequence_Prop(ISerializationContext context, Prop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.PROP__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.PROP__KEY));
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.PROP__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.PROP__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropAccess().getKeyValidStringParserRuleCall_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getPropAccess().getValueQSTRINGParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyFileSimple returns PropertyFile
	 *
	 * Constraint:
	 *     location=ValidString
	 */
	protected void sequence_PropertyFileSimple(ISerializationContext context, PropertyFile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.PROPERTY_FILE__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.PROPERTY_FILE__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyFileSimpleAccess().getLocationValidStringParserRuleCall_1_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyFile returns PropertyFile
	 *
	 * Constraint:
	 *     (location=ValidString | fileEncoding=ValidString)+
	 */
	protected void sequence_PropertyFile(ISerializationContext context, PropertyFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns PropertyOverride
	 *     ContextType returns PropertyOverride
	 *     PropertyHolder returns PropertyOverride
	 *     PropertyOverride returns PropertyOverride
	 *
	 * Constraint:
	 *     (
	 *         propertyfile=PropertyFile | 
	 *         ignoreResourceNotFound=sBoolean | 
	 *         ignoreUnresolvable=sBoolean | 
	 *         localOverride=sBoolean | 
	 *         order=ValidString | 
	 *         propertiesRef=[Component|ValidString]
	 *     )+
	 */
	protected void sequence_PropertyOverride(ISerializationContext context, PropertyOverride semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns PropertyPlaceholder
	 *     ContextType returns PropertyPlaceholder
	 *     PropertyHolder returns PropertyPlaceholder
	 *     PropertyPlaceholder returns PropertyPlaceholder
	 *
	 * Constraint:
	 *     (
	 *         propertyfile=PropertyFile | 
	 *         ignoreResourceNotFound=sBoolean | 
	 *         ignoreUnresolvable=sBoolean | 
	 *         localOverride=sBoolean | 
	 *         order=ValidString | 
	 *         propertiesRef=[Component|ValidString] | 
	 *         systemPropertiesMode=ValidString
	 *     )+
	 */
	protected void sequence_PropertyPlaceholder(ISerializationContext context, PropertyPlaceholder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ((name=ValidString | artefact=ReferenceAtt | artefact=AttributeAtt)+ description=Description?) | 
	 *         (name=ValidString description=Description? artefact=AbstractArtefact?)
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Props
	 *     AbstractArtefact returns Props
	 *     Collection returns Props
	 *     Props returns Props
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? props+=Prop*)
	 */
	protected void sequence_Props(ISerializationContext context, Props semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualifierAttribute returns QualifierAttribute
	 *
	 * Constraint:
	 *     (key=ValidString | value=ValidString)+
	 */
	protected void sequence_QualifierAttribute(ISerializationContext context, QualifierAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Qualifier
	 *
	 * Constraint:
	 *     ((type=ValidString | value=ValidString)* qualifierAttributes+=QualifierAttribute*)
	 */
	protected void sequence_Qualifier(ISerializationContext context, Qualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceAtt returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_ReferenceAtt(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAttAccess().getRefComponentValidStringParserRuleCall_2_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceComponent returns Reference
	 *
	 * Constraint:
	 *     ref=[Component|ValidString]
	 */
	protected void sequence_ReferenceComponent(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceComponentAccess().getRefComponentValidStringParserRuleCall_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns Reference
	 *     AbstractArtefact returns Reference
	 *     ReferenceTag returns Reference
	 *
	 * Constraint:
	 *     ref=[AbstractArtefact|ValidString]
	 */
	protected void sequence_ReferenceTag(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpringDSLPackage.Literals.REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceTagAccess().getRefAbstractArtefactValidStringParserRuleCall_3_0_1(), semanticObject.eGet(SpringDSLPackage.Literals.REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns SpringConfigured
	 *     ContextType returns SpringConfigured
	 *     SpringConfigured returns SpringConfigured
	 *
	 * Constraint:
	 *     {SpringConfigured}
	 */
	protected void sequence_SpringConfigured(ISerializationContext context, SpringConfigured semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpringProject returns SpringProject
	 *
	 * Constraint:
	 *     configurations+=Configuration*
	 */
	protected void sequence_SpringProject(ISerializationContext context, SpringProject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxAdvise returns TxAdvise
	 *
	 * Constraint:
	 *     ((name=ValidString | transactionManager=ValidString)* txAttribute=TxAttribute?)
	 */
	protected void sequence_TxAdvise(ISerializationContext context, TxAdvise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxAttribute returns TxAttribute
	 *
	 * Constraint:
	 *     txMethods+=TxMethod+
	 */
	protected void sequence_TxAttribute(ISerializationContext context, TxAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxJtaTransactionManager returns TxJtaTransactionManager
	 *
	 * Constraint:
	 *     {TxJtaTransactionManager}
	 */
	protected void sequence_TxJtaTransactionManager(ISerializationContext context, TxJtaTransactionManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TxMethod returns TxMethod
	 *
	 * Constraint:
	 *     (
	 *         name=ValidString | 
	 *         isolation=EnumIsolation | 
	 *         noRollBackFor=ValidString | 
	 *         propagation=EnumIsolation | 
	 *         readOnly=sBoolean | 
	 *         rollbackFor=ValidString | 
	 *         timeOut=ValidString
	 *     )+
	 */
	protected void sequence_TxMethod(ISerializationContext context, TxMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilConstant
	 *     AbstractArtefact returns UtilConstant
	 *     AttributeTag returns UtilConstant
	 *     UtilConstant returns UtilConstant
	 *
	 * Constraint:
	 *     (StaticField=STRING | name=ValidString)*
	 */
	protected void sequence_UtilConstant(ISerializationContext context, UtilConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilList
	 *     AbstractArtefact returns UtilList
	 *     Collection returns UtilList
	 *     sList returns UtilList
	 *     UtilList returns UtilList
	 *
	 * Constraint:
	 *     ((name=ValidString | listClass=ValidString | scope=ValidString | valueType=ValidString)* artefacts+=AbstractArtefact*)
	 */
	protected void sequence_UtilList(ISerializationContext context, UtilList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilMap
	 *     AbstractArtefact returns UtilMap
	 *     Collection returns UtilMap
	 *     Map returns UtilMap
	 *     UtilMap returns UtilMap
	 *
	 * Constraint:
	 *     ((name=ValidString | keyType=ValidString | mapClass=ValidString | scope=ValidString | valueType=ValidString)* entries+=MapEntry*)
	 */
	protected void sequence_UtilMap(ISerializationContext context, UtilMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilProperties
	 *     AbstractArtefact returns UtilProperties
	 *     Collection returns UtilProperties
	 *     Props returns UtilProperties
	 *     UtilProperties returns UtilProperties
	 *
	 * Constraint:
	 *     (
	 *         propertyfile=PropertyFileSimple | 
	 *         name=ValidString | 
	 *         ignoreResourceNotFound=sBoolean | 
	 *         localOverride=sBoolean | 
	 *         scope=ValidString | 
	 *         valueType=ValidString | 
	 *         props+=Prop
	 *     )*
	 */
	protected void sequence_UtilProperties(ISerializationContext context, UtilProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UtilPropertyPath returns UtilPropertyPath
	 *
	 * Constraint:
	 *     (name=ValidString | path=ValidString)+
	 */
	protected void sequence_UtilPropertyPath(ISerializationContext context, UtilPropertyPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns UtilSet
	 *     AbstractArtefact returns UtilSet
	 *     Collection returns UtilSet
	 *     sSet returns UtilSet
	 *     UtilSet returns UtilSet
	 *
	 * Constraint:
	 *     ((name=ValidString | setClass=ValidString | scope=ValidString | valueType=ValidString)* artefacts+=AbstractArtefact*)
	 */
	protected void sequence_UtilSet(ISerializationContext context, UtilSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns sList
	 *     AbstractArtefact returns sList
	 *     Collection returns sList
	 *     sList returns sList
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? artefacts+=AbstractArtefact*)
	 */
	protected void sequence_sList(ISerializationContext context, sList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractKeyValue returns sSet
	 *     AbstractArtefact returns sSet
	 *     Collection returns sSet
	 *     sSet returns sSet
	 *
	 * Constraint:
	 *     ((valueType=ValidString | merge=DefaultableBoolean)* description=Description? artefacts+=AbstractArtefact*)
	 */
	protected void sequence_sSet(ISerializationContext context, sSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
